     1                                  %include "boot.inc"
     1                              <1> ;-------------	 loader和kernel   ----------
     2                              <1> 
     3                              <1> LOADER_BASE_ADDR equ 0x900 
     4                              <1> LOADER_STACK_TOP equ LOADER_BASE_ADDR
     5                              <1> LOADER_START_SECTOR equ 0x2
     6                              <1> 
     7                              <1> KERNEL_BIN_BASE_ADDR equ 0x70000
     8                              <1> KERNEL_START_SECTOR equ 0x9
     9                              <1> KERNEL_ENTRY_POINT equ 0xc0001500
    10                              <1> 
    11                              <1> ;-------------   页表配置   ----------------
    12                              <1> 
    13                              <1> ;---------------gdt描述符性质------------------
    14                              <1> 
    15                              <1> ; DESC_G_4K equ 0x800000   ;23bit offset from 0bit
    16                              <1> ; DESC_D_32 equ 0x400000   ;22   D 1/0 操作数32/16bit选择位
    17                              <1> ; DESC_L    equ 0x000000   ;21   是否是64位代码段 这里选择0 否 32位模式
    18                              <1> 
    19                              <1> ; ;64位代码标记此处标记为０即可
    20                              <1> ; DESC_AVL  equ 0x000000   ;20 CPU此位不用暂时为0
    21                              <1> ; DESC_LIMIT_CODEC2  equ  0xf0000  ;段的界限16-19
    22                              <1> ; DESC_LIMIT_DATA2   equ  DESC_LIMIT_CODEC2
    23                              <1> ; DESC_LIMIT_VIDEO2  equ  0x00000
    24                              <1> ; DESC_P    equ 0x8000  ;bit 15  段是否存在的检查结果cpu给的
    25                              <1> ; ;bit 14 13
    26                              <1> ; DESC_DPL_0 equ 0x0000 ;DPL bit14 13  (0--0)2 (0 00)16 程序的特权阶级
    27                              <1> ; DESC_DPL_1 equ 0x2000
    28                              <1> ; DESC_DPL_2 equ 0x4000
    29                              <1> ; DESC_DPL_3 equ 0x6000
    30                              <1> ; ;bit 12
    31                              <1> ; DESC_S_CODE equ 0x1000  ;S字段  0/1 系统段/数据段
    32                              <1> ; DESC_S_DATA equ DESC_S_CODE
    33                              <1> ; DESC_S_sys  equ 0x0000  ;
    34                              <1> ; ;bit 11-8
    35                              <1> ; DESC_TYPE_CODE equ 0x800 ;x=1 e=0 w=0 a=0  代码是可执行的 非一致 不可读，已访问位a清零 
    36                              <1> ; DESC_TYPE_DATA equ 0x200 ;  0   0   1   0   数据段是不可执行的 向上扩展 可写 已访问位a清零
    37                              <1> ; ------------------------------------------------------------------------
    38                              <1> DESC_G_4K equ 0x1<<23   ;23bit offset from 0bit
    39                              <1> DESC_D_32 equ 0x1<<22   ;22   D 1/0 操作数32/16bit选择位
    40                              <1> DESC_L    equ 0x000000   ;21   是否是64位代码段 这里选择0 否 32位模式
    41                              <1> 
    42                              <1> ;64位代码标记此处标记为０即可
    43                              <1> DESC_AVL  equ 0x0<<20   ;20 CPU此位不用暂时为0
    44                              <1> DESC_LIMIT_CODEC2  equ  0xf<<16  ;段的界限16-19
    45                              <1> DESC_LIMIT_DATA2   equ  DESC_LIMIT_CODEC2
    46                              <1> DESC_LIMIT_VIDEO2  equ  0x0<<16
    47                              <1> DESC_P    equ 0x1<<15  ;bit 15  段是否存在的检查结果cpu给的
    48                              <1> ;bit 14 13
    49                              <1> DESC_DPL_0 equ 0x0<<13 ;DPL bit14 13  (0--0)2 (0 00)16 程序的特权阶级
    50                              <1> DESC_DPL_1 equ 0x1<<13
    51                              <1> DESC_DPL_2 equ 0x2<<13
    52                              <1> DESC_DPL_3 equ 0x3<<13
    53                              <1> ;bit 12
    54                              <1> DESC_S_CODE equ 0x1<<12  ;S字段  0/1 系统段/数据段
    55                              <1> DESC_S_DATA equ DESC_S_CODE
    56                              <1> DESC_S_sys  equ 0x0<<12  ;
    57                              <1> ;bit 11-8
    58                              <1> DESC_TYPE_CODE equ 0x8<<8 ;x=1 e=0 w=0 a=0  代码是可执行的 非一致 不可读，已访问位a清零 
    59                              <1> DESC_TYPE_DATA equ 0x2<<8 ;  0   0   1   0   数据段是不可执行的 向上扩展 可写 已访问位a清零
    60                              <1> 
    61                              <1> 
    65                              <1> DESC_CODE_HIGH4 equ (0x00<<24)+DESC_G_4K+DESC_D_32+DESC_L+DESC_AVL+DESC_LIMIT_CODEC2+DESC_P+DESC_DPL_0+DESC_S_CODE+DESC_TYPE_CODE+0x00
    66                              <1> 
    70                              <1> DESC_DATA_HIGH4 equ (0x00<<24)+DESC_G_4K+DESC_D_32+DESC_L+DESC_AVL+DESC_LIMIT_DATA2+DESC_P+DESC_DPL_0+DESC_S_DATA+DESC_TYPE_DATA+0x00
    71                              <1> 
    75                              <1> DESC_VIDEO_HIGH4 equ (0x00<<24)+DESC_G_4K+DESC_D_32+DESC_L+DESC_AVL+DESC_LIMIT_VIDEO2+DESC_DPL_0+DESC_P+DESC_S_DATA+DESC_TYPE_DATA+0x0b ;黑白模式下的b8000地址 高位b留在了高32位的控制字段上
    76                              <1> 
    77                              <1> ;-------------选择子属性----------------
    78                              <1> RPL0 equ 00b
    79                              <1> RPL1 equ 01b
    80                              <1> RPL2 equ 10b
    81                              <1> RPL3 equ 11b
    82                              <1> 
    83                              <1> TI_GDT equ 000b
    84                              <1> TI_LDT equ 100b
    85                              <1> 
    86                              <1> ; -----------页相关属性--------------------------
    87                              <1> PAGE_DIR_TABLE_POS equ 0x100000
    88                              <1> 
    89                              <1> PG_P equ 1b
    90                              <1> PG_RW_R equ 00b
    91                              <1> PG_RW_W EQU 10b
    92                              <1> PG_US_S EQU 000B
    93                              <1> PG_US_U EQU 100B
    94                              <1> 
    95                              <1> ;-------------  program type 定义   --------------
    96                              <1> PT_NULL equ 0
     2                                  
     3                                  section loader vstart=LOADER_BASE_ADDR
     4                                  
     5 00000000 E91203                  jmp loader_start
     6                                  ;-----构建GDT内部的描述符------
     7 00000003 00000000                GDT_BASE: dd 0x00000000
     8 00000007 00000000                          dd 0x00000000
     9                                  
    10 0000000B FFFF0000                CODE_DESC: dd 0x0000ffff
    11 0000000F 0098CF00                           dd DESC_CODE_HIGH4
    12                                  
    13 00000013 FFFF0000                DATA_DESC: dd 0x0000ffff
    14 00000017 0092CF00                           dd DESC_DATA_HIGH4
    15                                  
    16 0000001B 07000080                VIDEO_DESC: dd 0x80000007   ;limit=(0xbffff-0xb8000)/4k=0x7  低16位为段的界限  
    17 0000001F 0B92C000                            dd DESC_VIDEO_HIGH4  ;此时dpl=0
    18                                  
    19                                  
    20 00000023 0000000000000000-       times 60 dq 0    ;此处预留60个描述符的空位
    20 00000023 <rept>             
    21                                  
    22                                  ;equ 这种类似于宏定义 是不占内存空间的 会直接替换
    23                                  
    24                                  GDT_SIZE equ $-GDT_BASE
    25                                  GDT_LIMIT equ GDT_SIZE-1
    26                                  
    27                                  SELECTOR_CODE equ (0x0001<<3)+TI_GDT+RPL0   ;TI 表示在GDT中索引描述符 RPL特权级
    28                                  SELECTOR_DATA equ (0x0002<<3)+TI_GDT+RPL0
    29                                  SELECTOR_VIDEO equ (0x0003<<3)+TI_GDT+RPL0
    30                                  
    31                                  
    32                                  
    33                                  
    34                                  ;一个段描述符8个字节 8*64=2^9 byte
    35                                  ;用于保存内存的容量 以字节为单位  此处的偏移地址为0x900+0x200=0xb00
    36 00000203 00000000                total_mem_bytes dd 0    
    37                                  
    38 00000207 FF01                    gdt_ptr dw GDT_LIMIT
    39 00000209 [03000000]                      dd GDT_BASE
    40                                  
    41                                  ;;;人工对齐 from total_mem_bytes to ards_nr 4+6+244+2=256 offset bytes
    42 0000020D 00<rept>                ards_buf times 244 db 0
    43 00000301 0000                    ards_nr dw 0       ;记录ards结构体的数量
    44                                  ; 0xc00
    45 00000303 32206C6F6164657220-     loadermsg db '2 loader in real.'
    45 0000030C 696E207265616C2E   
    46 00000314 00                      type_msg db 0
    47                                  strlen equ $-loadermsg
    48                                  
    49                                  
    50                                  loader_start:
    51                                  ;-------------------------------------
    52                                  ;INT 10 功能号13 功能描述：打印字符串
    53                                  ;-------------------------------------
    54                                  ;AH:功能号13
    55                                  ;BH:页码
    56                                  ;BL:属性（若AL=00H或01H）
    57                                  ;CX:字符串长度
    58                                  ;（DH,DL）=坐标的（row,col）
    59                                  ;ES,BP:字符串地址
    60                                  ;AL:显示输出的方z式
    61                                  ;    0：字符串只含显示字符。其显示属性在AL中；显示后光标的位置不变
    62                                  ;    1：字符串只含显示字符。其显示属性在AL中；显示后光标的位置变
    63                                  ;    2：字符串含有显示字符和属性，显示后光标位置不变
    64                                  ;    3：字符串含有显示字符和属性，显示后光标位置变
    65                                  ;
    66                                  ;无返回值
    67 00000315 BC0009                      mov sp,LOADER_BASE_ADDR
    68 00000318 BD[0303]                    mov bp,loadermsg
    69 0000031B B91200                      mov cx,strlen
    70 0000031E B80113                      mov ax,0x1301 ;AH=13 AL=01
    71 00000321 BB1F00                      mov bx,0x001f ;页号为0(BH=0h) 蓝底粉色字（BL=1Fh）
    72 00000324 BA0018                      mov dx,0x1800   
    73 00000327 CD10                        int 0x10 
    74                                  ;---------------显示字符串结束----------------------------
    75                                  
    76                                  
    77                                  ;------------------内存检测-----------------------------------
    78                                  ; int 15h eax=000e820h,edx=534d4150h('SAMP') 获取内存布局
    79 00000329 6631DB                      xor ebx,ebx
    80 0000032C 66BA50414D53                mov edx,0x534d4150
    81 00000332 BF[0D02]                    mov di,ards_buf
    82                                  
    83 00000335 FE06[1403]                  inc byte [type_msg]
    84                                  
    85                                  .e820_mem_get_loop:
    86 00000339 66B820E80000                mov eax,0x0000e820  ;执行int 15以后 eax的值变为534d4150h  所以每次执行都要更新eax
    87 0000033F 66B914000000                mov ecx,20  ;ards 地址范围描述符的结构大小是20byte
    88 00000345 CD15                        int 0x15
    89                                  
    90 00000347 7232                        jc .e820_failed_so_try_e801  ;cf位为1则有错误发发生，则执行 0xe801子功能
    91                                  
    92 00000349 01CF                        add di,cx
    93 0000034B FF06[0103]                  inc word [ards_nr]
    94                                  
    95 0000034F 6683FB00                    cmp ebx,0  ;如果eab=0 cf=0 那么说明ards全部返回
    96 00000353 75E4                        jnz .e820_mem_get_loop
    97                                  
    98                                  ;在所有ards结构中找出（base_add_low+length_low）的最大值 即内存中的容量
    99 00000355 8B0E[0103]                  mov cx,[ards_nr]
   100 00000359 66BB[0D020000]              mov ebx,ards_buf
   101 0000035F 6631D2                      xor edx,edx
   102                                  
   103                                  .find_max_mem_area:
   104 00000362 66678B03                    mov eax,[ebx]
   105 00000366 6667034308                  add eax,[ebx+8]
   106 0000036B 6683C314                    add ebx,20
   107 0000036F 6639C2                      cmp edx,eax
   108 00000372 7D03                        jge .next_ards
   109 00000374 6689C2                      mov edx,eax   ;edx为总内存的大小存储的地方
   110                                  
   111                                  .next_ards:
   112 00000377 E2E9                        loop .find_max_mem_area
   113 00000379 EB60                        jmp .mem_get_ok
   114                                  ;-------------e820检查方式结束-----------------------------------------------
   115                                  
   116                                  
   117                                  ; ----------------------------------------------------
   118                                  ; int 15h ax=e801h 获取内存大小 最大支持4G
   119                                  ; 返回后ax与cx一样以1kb为单位   bx,dx一样以64kb为单位
   120                                  ; ax,cx寄存器存储低16M,dx,bx存储16M-4G
   121                                  
   122                                  .e820_failed_so_try_e801:
   123 0000037B FE06[1403]                  inc byte [type_msg]
   124                                  
   125 0000037F B801E8                      mov ax,0xe801
   126 00000382 CD15                        int 0x15
   127 00000384 7232                        jc  .e801_failed_so_try_e88
   128                                  
   129 00000386 B90004                      mov cx,0x400 ;1k为单位转换为byte
   130 00000389 F7E1                        mul cx
   131 0000038B 66C1E210                    shl edx,16  ;64k 为单位 转化为byte
   132 0000038F 6625FFFF0000                and eax,0x0000FFFF  ;此时还是16bit 实模式mul 16bit 结果保留在dx,ax
   133 00000395 6609C2                      or edx,eax
   134 00000398 6681C200001000              add edx,0x100000
   135 0000039F 6689D6                      mov esi,edx    ;此时将15M一下的内存计算出来
   136                                  
   137                                  ; 将16M以上的内存装换为byte
   138 000003A2 6631C0                      xor eax,eax
   139 000003A5 89D8                        mov ax,bx
   140 000003A7 66B900000100                mov ecx,0x10000
   141 000003AD 66F7E1                      mul ecx       ;mul 32bit时候结果地32位保留在eax
   142 000003B0 6601CE                      add esi,ecx      
   143 000003B3 6689F2                      mov edx,esi   ;edx为内存大小
   144                                  
   145 000003B6 EB23                        jmp .mem_get_ok
   146                                  ; ----------------e801检测方式结束-----------------------------
   147                                  
   148                                  ;------------------------------------------------------
   149                                  ; int 15h ah=0x88 获取内存大小，只能获取64M以内的
   150                                  .e801_failed_so_try_e88:
   151 000003B8 FE06[1403]                  inc byte [type_msg]
   152                                  
   153 000003BC B488                        mov ah,0x88
   154 000003BE CD88                        int 0x88
   155 000003C0 723B                        jc .error_hlt
   156                                  
   157 000003C2 B90004                      mov cx,0x400
   158 000003C5 F7E1                        mul cx
   159 000003C7 66C1E210                    shl edx,16
   160 000003CB 6625FFFF0000                and eax,0x0000ffff
   161 000003D1 6609C2                      or edx,eax
   162 000003D4 6681C200001000              add edx,0x100000
   163                                  
   164                                  
   165                                  
   166                                  .mem_get_ok:
   167 000003DB 668916[0302]                mov [total_mem_bytes],edx
   168                                  
   169                                  
   170                                  ;---------------------准备进入保护模式-----------------------------
   171                                  ;
   172                                  ;1 打开A20
   173                                  ;2 加载GDT
   174                                  ;3 将cr0的pe置1
   175                                  
   176 000003E0 E492                        in al,0x92
   177 000003E2 0C02                        or al,0x02
   178 000003E4 E692                        out 0x92,al
   179                                      
   180                                      ;-------------加载GDT-------------------------------------------
   181 000003E6 0F0116[0702]                lgdt [gdt_ptr]
   182                                  
   183                                  
   184                                      ;------------cr0 第0位置1---------------------------------------
   185 000003EB 0F20C0                      mov eax,cr0
   186 000003EE 6683C801                    or eax,0x01
   187 000003F2 0F22C0                      mov cr0,eax
   188                                  
   189 000003F5 66EA[FF030000]0800          jmp dword SELECTOR_CODE:p_mode_start
   190                                  
   191                                  .error_hlt:
   192 000003FD EBFE                        jmp $  ;程序悬停在此处
   193                                  
   194                                  
   195                                  [bits 32]
   196                                  p_mode_start:
   197 000003FF 66B81000                    mov ax,SELECTOR_DATA
   198 00000403 8ED8                        mov ds,ax
   199 00000405 8EC0                        mov es,ax
   200 00000407 8ED0                        mov ss,ax
   201 00000409 BC00090000                  mov esp,LOADER_STACK_TOP
   202 0000040E 66B81800                    mov ax,SELECTOR_VIDEO
   203 00000412 8EE8                        mov gs,ax
   204                                  ; ------------------加载内核-----------------------
   205 00000414 B809000000                  mov eax,KERNEL_START_SECTOR ;kernel.bin所在的扇区号
   206 00000419 BB00000700                  mov ebx,KERNEL_BIN_BASE_ADDR ;从硬盘读出后写到ebx指定的地址
   207 0000041E B9C8000000                  mov ecx,200
   208 00000423 E844010000                  call rd_disk_m_32
   209                                  
   210                                  ; ------------------------------------------------
   211 00000428 E8C5000000                  call setup_page
   212                                  
   213                                      ; 先将描述符表地址偏移量写入内存 一会重新加载
   214 0000042D 0F0105[07020000]            sgdt [gdt_ptr]
   215                                  
   216                                      ; 修改gdt中视频段的段描述符的段基址+0xc0000000
   217 00000434 8B1D[09020000]              mov ebx,[gdt_ptr+2] ;
   218 0000043A 814B1C000000C0              or dword [ebx+0x18+4],0xc0000000
   219                                      
   220                                      ; 将gdt的基址加上0xc0000000成为高地址
   221 00000441 8105[09020000]0000-         add dword [gdt_ptr+2],0xc0000000
   221 00000449 00C0               
   222                                      ; 修改栈的指针
   223 0000044B 81C4000000C0                add esp,0xc0000000
   224                                  
   225                                      ; 将page目录地址赋值给cr3
   226 00000451 B800001000                  mov eax,PAGE_DIR_TABLE_POS
   227 00000456 0F22D8                      mov cr3,eax
   228                                  
   229                                      ; 打开CR0的Pg位
   230 00000459 0F20C0                      mov eax,cr0
   231 0000045C 0D00000080                  or eax,0x1<<31
   232 00000461 0F22C0                      mov cr0,eax
   233                                  
   234 00000464 0F0115[07020000]            lgdt [gdt_ptr]  ;重新载入页表刷新
   235                                  
   236 0000046B EA[72040000]0800            jmp SELECTOR_CODE:enter_kernel
   237                                  
   238                                  enter_kernel:
   239 00000472 E80A000000                  call kerne_init
   240 00000477 BC00F009C0                  mov esp,0xc009f000
   241 0000047C E9(001500C0)                jmp KERNEL_ENTRY_POINT
   242                                  
   243                                  ; -------------kernal载入相关------------------------
   244                                  kerne_init:
   245 00000481 31C0                        xor eax,eax
   246 00000483 31DB                        xor ebx,ebx ;ebx记录程序头表地址
   247 00000485 31C9                        xor ecx,ecx ;cx记录program header数量
   248 00000487 31D2                        xor edx,edx ;dx 记录program header尺寸 e_phentsize
   249                                  
   250 00000489 668B152A000700              mov dx,[KERNEL_BIN_BASE_ADDR+42] ;偏移文件42字节处是属性e_phentsize 
   251 00000490 8B1D1C000700                mov ebx,[KERNEL_BIN_BASE_ADDR+28];偏移文件28字节的 e_phoff 表示第一个program header在文件中的偏移量
   252                                  
   253 00000496 81C300000700                add ebx,KERNEL_BIN_BASE_ADDR ;e_phoff+base_addr=program header start:[p_type]
   254                                  
   255 0000049C 668B0D2C000700              mov cx,[KERNEL_BIN_BASE_ADDR+44] ;偏移部分44byte 是e_phnum 表示有几个program header
   256                                  
   257                                  
   258                                  .each_segment:
   259 000004A3 803B00                      cmp byte [ebx+0],PT_NULL
   260 000004A6 7417                        je .PTNULL
   261                                      ; 为函数mem_cpy压人参数，参数是从右往左依次压人
   262                                      ; 为参数 mem_cpy(dst,src,size)
   263                                  
   264 000004A8 FF7310                      push dword [ebx+16]  ;p_type + offset 16 byte =p_filesz 本段在文件中的大小
   265 000004AB 8B4304                      mov eax,[ebx+4] ;p_offset 本段在文件类的起始偏移字节
   266 000004AE 0500000700                  add eax,KERNEL_BIN_BASE_ADDR  ;加法以后 eax代表内核文件被加载的地址+段的偏移地址
   267 000004B3 50                          push eax ;压人第二个参数 src addr
   268 000004B4 FF7308                      push dword [ebx+8] ;压人第一个参数 目的地址 
   269                                  
   270 000004B7 E808000000                  call mem_cpy
   271                                  
   272 000004BC 83C40C                      add esp,12 ;清理栈中的三个参数
   273                                      
   274                                  
   275                                  
   276                                  .PTNULL:
   277                                  ;   该段可以忽略 通过增加偏移地址使得移动到可执行的段
   278 000004BF 01D3                        add ebx,edx ;edx 为program header的大小
   279 000004C1 E2E0                        loop .each_segment
   280 000004C3 C3                          ret 
   281                                  
   282                                  ; -----------------逐字节拷贝----------------------------
   283                                  mem_cpy:
   284 000004C4 FC                          cld 
   285 000004C5 55                          push ebp
   286 000004C6 89E5                        mov ebp,esp
   287 000004C8 51                          push ecx
   288                                  
   289 000004C9 8B7D08                      mov edi,[ebp+8]  ;dst
   290 000004CC 8B750C                      mov esi,[ebp+12] ;src
   291 000004CF 8B4D10                      mov ecx,[ebp+16] ;size
   292 000004D2 F3A4                        rep movsb  ;逐字节拷贝
   293                                  
   294                                      ; 恢复环境
   295 000004D4 59                          pop ecx
   296 000004D5 5D                          pop ebp
   297 000004D6 C3                          ret 
   298                                  
   299                                  ; ---------------------------------------------------
   300                                      ; 显示进入的模式 1,2,3
   301 000004D7 66B83000                    mov ax,48  ;0的ascii 48
   302 000004DB 660305[14030000]            add ax,[type_msg]
   303 000004E2 65A2A0000000                mov byte [gs:160],al
   304                                  
   305 000004E8 65C605A1000000A4            mov byte [gs:161],0xa4
   306 000004F0 EBFE                        jmp $
   307                                  
   308                                  
   309                                  
   310                                  
   311                                  ; --------------页表设置----------------------------
   312                                  setup_page:
   313 000004F2 B900100000                  mov ecx,4096
   314 000004F7 BE00000000                  mov esi,0
   315                                  
   316                                  ;先把目录页的所占空间全部清0
   317                                  .clear_page_dir:
   318 000004FC C6860000100000              mov byte [PAGE_DIR_TABLE_POS+esi],0
   319 00000503 46                          inc esi
   320 00000504 E2F6                        loop .clear_page_dir
   321                                  
   322                                  ; 开始创建页PDE目录项
   323                                  .create_pde:
   324 00000506 B800001000                  mov eax,PAGE_DIR_TABLE_POS
   325 0000050B 0500100000                  add eax,0x1000 
   326 00000510 89C3                        mov ebx,eax  ;为create pte做准备 此处存放的是第一个页表的地址
   327                                      ;设置页目录项目的属性
   328 00000512 83C807                      or eax, PG_US_U|PG_RW_W|PG_P
   329 00000515 A300001000                  mov [PAGE_DIR_TABLE_POS],eax   ;第一个目录项 目前在实模式 防止模式切换以后！m控件变了
   330                                      ;虚拟内存中3-4G内存分布的是操作系统 作为共享区域供进程调用 0xc00/4=index
   331 0000051A A3000C1000                  mov [PAGE_DIR_TABLE_POS+0xc00],eax
   332                                  
   333 0000051F 2D00100000                  sub eax,0x1000
   334 00000524 A3FC0F1000                  mov [PAGE_DIR_TABLE_POS+4092],eax ;页表项的最以后一项指向PDE的地址
   335                                  
   336                                  ;   下面创建页表项
   337 00000529 B900010000                  mov ecx,256
   338 0000052E BE00000000                  mov esi,0
   339 00000533 BA07000000                  mov edx,PG_P|PG_RW_W|PG_US_U
   340                                  
   341                                  .create_pte:
   342                                      ; 在页表项中写入对应的4k表的地址  0-1M 共256个页表项
   343 00000538 8914B3                      mov [ebx+esi*4],edx
   344 0000053B 81C200100000                add edx,4096
   345 00000541 46                          inc esi
   346 00000542 E2F4                        loop .create_pte
   347                                  
   348                                  ; 创建内核以及其他页表
   349 00000544 B800001000                  mov eax,PAGE_DIR_TABLE_POS
   350 00000549 0500200000                  add eax,0x2000  
   351 0000054E 83C807                      or eax,PG_P|PG_RW_W|PG_US_U
   352 00000551 BB00001000                  mov ebx,PAGE_DIR_TABLE_POS
   353 00000556 B9FE000000                  mov ecx,254
   354 0000055B BE01030000                  mov esi,769  
   355                                  .create_kernal_pde:  ;将PDE 0xc0 index上的全部
   356 00000560 8904B3                      mov [ebx+esi*4],eax
   357 00000563 46                          inc esi 
   358 00000564 0500100000                  add eax,0x1000
   359 00000569 E2F5                        loop .create_kernal_pde
   360                                  
   361 0000056B C3                          ret 
   362                                  
   363                                  ;-------------------------------------------------------------------------------
   364                                  			   ;功能:读取硬盘n个扇区 将内核文件迁移到内存
   365                                  rd_disk_m_32:	   
   366                                  ;-------------------------------------------------------------------------------
   367                                  							 ; eax=LBA扇区号
   368                                  							 ; ebx=将数据写入的内存地址
   369                                  							 ; ecx=读入的扇区数
   370 0000056C 89C6                          mov esi,eax	   ; 备份eax
   371 0000056E 6689CF                        mov di,cx		   ; 备份扇区数到di
   372                                  ;读写硬盘:
   373                                  ;第1步：设置要读取的扇区数
   374 00000571 66BAF201                      mov dx,0x1f2
   375 00000575 88C8                          mov al,cl
   376 00000577 EE                            out dx,al            ;读取的扇区数
   377                                  
   378 00000578 89F0                          mov eax,esi	   ;恢复ax
   379                                  
   380                                  ;第2步：将LBA地址存入0x1f3 ~ 0x1f6
   381                                  
   382                                        ;LBA地址7~0位写入端口0x1f3
   383 0000057A 66BAF301                      mov dx,0x1f3                       
   384 0000057E EE                            out dx,al                          
   385                                  
   386                                        ;LBA地址15~8位写入端口0x1f4
   387 0000057F B108                          mov cl,8
   388 00000581 D3E8                          shr eax,cl
   389 00000583 66BAF401                      mov dx,0x1f4
   390 00000587 EE                            out dx,al
   391                                  
   392                                        ;LBA地址23~16位写入端口0x1f5
   393 00000588 D3E8                          shr eax,cl
   394 0000058A 66BAF501                      mov dx,0x1f5
   395 0000058E EE                            out dx,al
   396                                  
   397 0000058F D3E8                          shr eax,cl
   398 00000591 240F                          and al,0x0f	   ;lba第24~27位
   399 00000593 0CE0                          or al,0xe0	   ; 设置7～4位为1110,表示lba模式
   400 00000595 66BAF601                      mov dx,0x1f6
   401 00000599 EE                            out dx,al
   402                                  
   403                                  ;第3步：向0x1f7端口写入读命令，0x20 
   404 0000059A 66BAF701                      mov dx,0x1f7
   405 0000059E B020                          mov al,0x20                        
   406 000005A0 EE                            out dx,al
   407                                  
   408                                  ;;;;;;; 至此,硬盘控制器便从指定的lba地址(eax)处,读出连续的cx个扇区,下面检查硬盘状态,不忙就能把这cx个扇区的数据读出来
   409                                  
   410                                  ;第4步：检测硬盘状态
   411                                    .not_ready:		   ;测试0x1f7端口(status寄存器)的的BSY位
   412                                        ;同一端口,写时表示写入命令字,读时表示读入硬盘状态
   413 000005A1 90                            nop
   414 000005A2 EC                            in al,dx
   415 000005A3 2488                          and al,0x88	   ;第4位为1表示硬盘控制器已准备好数据传输,第7位为1表示硬盘忙
   416 000005A5 3C08                          cmp al,0x08
   417 000005A7 75F8                          jnz .not_ready	   ;若未准备好,继续等。
   418                                  
   419                                  ;第5步：从0x1f0端口读数据
   420 000005A9 6689F8                        mov ax, di	   ;以下从硬盘端口读数据用insw指令更快捷,不过尽可能多的演示命令使用,
   421                                  			   ;在此先用这种方法,在后面内容会用到insw和outsw等
   422                                  
   423 000005AC 66BA0001                      mov dx, 256	   ;di为要读取的扇区数,一个扇区有512字节,每次读入一个字,共需di*512/2次,所以di*256
   424 000005B0 66F7E2                        mul dx
   425 000005B3 6689C1                        mov cx, ax	   
   426 000005B6 66BAF001                      mov dx, 0x1f0
   427                                    .go_on_read:
   428 000005BA 66ED                          in ax,dx		
   429 000005BC 668903                        mov [ebx], ax
   430 000005BF 83C302                        add ebx, 2
   431                                  			  ; 由于在实模式下偏移地址为16位,所以用bx只会访问到0~FFFFh的偏移。
   432                                  			  ; loader的栈指针为0x900,bx为指向的数据输出缓冲区,且为16位，
   433                                  			  ; 超过0xffff后,bx部分会从0开始,所以当要读取的扇区数过大,待写入的地址超过bx的范围时，
   434                                  			  ; 从硬盘上读出的数据会把0x0000~0xffff的覆盖，
   435                                  			  ; 造成栈被破坏,所以ret返回时,返回地址被破坏了,已经不是之前正确的地址,
   436                                  			  ; 故程序出会错,不知道会跑到哪里去。
   437                                  			  ; 所以改为ebx代替bx指向缓冲区,这样生成的机器码前面会有0x66和0x67来反转。
   438                                  			  ; 0X66用于反转默认的操作数大小! 0X67用于反转默认的寻址方式.
   439                                  			  ; cpu处于16位模式时,会理所当然的认为操作数和寻址都是16位,处于32位模式时,
   440                                  			  ; 也会认为要执行的指令是32位.
   441                                  			  ; 当我们在其中任意模式下用了另外模式的寻址方式或操作数大小(姑且认为16位模式用16位字节操作数，
   442                                  			  ; 32位模式下用32字节的操作数)时,编译器会在指令前帮我们加上0x66或0x67，
   443                                  			  ; 临时改变当前cpu模式到另外的模式下.
   444                                  			  ; 假设当前运行在16位模式,遇到0X66时,操作数大小变为32位.
   445                                  			  ; 假设当前运行在32位模式,遇到0X66时,操作数大小变为16位.
   446                                  			  ; 假设当前运行在16位模式,遇到0X67时,寻址方式变为32位寻址
   447                                  			  ; 假设当前运行在32位模式,遇到0X67时,寻址方式变为16位寻址.
   448 000005C2 E2F6                          loop .go_on_read
   449 000005C4 C3                            ret
   450                                  
   451                                  
